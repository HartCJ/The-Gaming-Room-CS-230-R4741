The client is The Gaming Room is a (fictional) company with a successful, preexisting Android game called _Draw It or Lose It_. The client requires a multiplayer, cross-platform application which will allow _Draw It or Lose It_ to run in desktop browser environments, with security and compatibility as high priorities.

In writing this document, I feel I did a particularly good job summarizing platforms and architectures in order to make effective recommendations for The Gaming Room's deployment platforms.

I found having a clear outline of what, exactly, the code needed to accomplish to be very helpful in writing the code. This method of outlining design constraints and requirements is something I have since begun taking into account more seriously in the context of my own projects.

If I could choose just one part of my document to revise, it would be the first overview section. I feel that when I completed that work, I did not yet have a proper understanding of or respect for the details to include or disclude and was too focused on avoiding redundancy with later sections while also missing the mark on certain valuable fundamentals. I would like to expand on my system architecture view and better hash out the requirements and design constraints.

I interpreted the user's needs by evaluating not just the most direct way to accomplish a particular goal but by also considering what may be most practical and cost-effective given the resources already available to the client. In implementing this, I considered that Java would likely offer the best opportunity to recycle code from the Android application while requiring little specialized, system-specific knowledge due to the function of the JVM. Java's unique inability to directly modify system memory also serves as an appealing addition to the client's desire for security. Regarding deployment, I ultimately concluded that a cloud-based environment would be ideal for a moderate-to-low packet volume, worldwide multiplayer game both in both cost and service.

I very much appreciated the perspective offered by Joel Spolsky's blog posts on many aspects of software design. While this project was fairly light on functional specifications, adopting a mindset of modularizing otherwise abstract ideas about the runtime of an application into linear clusters of functionality has greatly improved my ability to spot problems and implement unique solutions with less trial and error. In general, the idea of coming as close as possible to designing a logically functional application without writing code appeals to me as a guiding design philosophy for software.
